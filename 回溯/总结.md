- 组合
不在意顺序，也就是不同顺序一样元素算一个
- 排列
在意顺序，不同顺序一样元素算多个
- 子集
- 
- 分割
**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！
因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度就构成了树的深度**。
递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。
在讲[二叉树的递归 (opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)中我们说了递归三部曲，这里我再给大家列出回溯三部曲。
- 回溯函数模板返回值以及参数
在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。
回溯算法中函数返回值一般为void。
再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。
回溯函数伪代码如下：
```
void backtracking(参数)
```

- 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)的时候，就知道遍历树形结构一定要有终止条件。
所以回溯也有要终止条件。
什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
所以回溯函数终止条件伪代码如下：
```
if (终止条件) {
    存放结果;
    return;
}
```
- 回溯搜索的遍历过程
在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
如图：

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

注意图中，我特意举例集合大小和孩子的数量是相等的！
回溯函数遍历过程伪代码如下：
```
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```
for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。
backtracking这里自己调用自己，实现递归。
大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。
分析完过程，回溯算法模板框架如下：
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```


```c++
private:

        const string letterMap[10] = {

            "", // 0

            "", // 1

            "abc", // 2

            "def", // 3

            "ghi", // 4

            "jkl", // 5

            "mno", // 6

            "pqrs", // 7

            "tuv", // 8

            "wxyz", // 9

        };
```

```c++
class Solution {

public:

    // 主函数，返回所有回文分割方案

    vector<vector<string>> partition(string s) {

        vector<vector<string>> res;      // 存储所有有效的分割方案

        vector<string> current;          // 当前的分割路径

        backtrack(s, 0, current, res);  // 开始回溯

        return res;

    }

private:

    // 回溯函数

    void backtrack(const string& s, int start, vector<string>& current, vector<vector<string>>& res) {

        // 如果起始索引已经到达字符串末尾，说明找到一个有效的分割方案

        if (start == s.size()) {

            res.push_back(current);

            return;

        }

        // 从当前起始索引开始，尝试所有可能的子串

        for (int end = start; end < s.size(); ++end) {

            // 提取子串 [start, end]

            string substring = s.substr(start, end - start + 1);

            // 检查子串是否为回文

            if (isPalindrome(substring)) {

                // 如果是回文，则将其加入当前路径

                current.push_back(substring);

                // 递归处理剩余的字符串

                backtrack(s, end + 1, current, res);

                // 回溯，移除最后一个子串

                current.pop_back();

            }

        }

    }

    // 辅助函数，检查一个字符串是否为回文

    bool isPalindrome(const string& s) {

        int left = 0;

        int right = s.size() - 1;

        while (left < right) {

            if (s[left] != s[right])

                return false;

            left++;

            right--;

        }

        return true;

    }

};
```


```c++
#include <vector>

#include <string>

using namespace std;

  

class Solution {

public:

    bool exist(vector<vector<char>>& board, string word) {

        int rows = board.size();

        if(rows == 0) return false;

        int cols = board[0].size();

        for(int i = 0; i < rows; ++i){

            for(int j = 0; j < cols; ++j){

                if(backtracking(board, word, i, j, 0))

                    return true;

            }

        }

        return false;

    }

  

private:

    bool backtracking(vector<vector<char>>& board, const string& word, int i, int j, int index){

        // 边界条件检查

        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[index])

            return false;

        // 如果当前字符是最后一个字符，并且匹配成功

        if(index == word.size() - 1)

            return true;

        // 标记当前单元格已访问

        char temp = board[i][j];

        board[i][j] = '#'; // 使用特殊字符标记，避免使用额外的空间

        // 四个方向搜索

        bool found = backtracking(board, word, i+1, j, index+1) ||

                     backtracking(board, word, i-1, j, index+1) ||

                     backtracking(board, word, i, j+1, index+1) ||

                     backtracking(board, word, i, j-1, index+1);

        // 恢复原来的字符

        board[i][j] = temp;

        return found;

    }

};
```


startIndex(0,s.size())
s = s.substr(startIndex,i-startIndex+1)


```c++
        for (int i = startIndex; i < s.size(); i++) {

            if (isPalindrome(s, startIndex, i)) {

                // 是回文子串

                string str = s.substr(startIndex, i - startIndex + 1);

                path.push_back(str);

                backtracking(s, i + 1);

                path.pop_back(); // 回溯

            }

            // 如果不是回文，直接继续下一个，不需要else

        }
```