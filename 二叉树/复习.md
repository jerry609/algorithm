## 104 二叉树的最大深度

后续遍历

## 中序遍历
递归
==栈==

## 反转二叉树

层序遍历

## 对称二叉树
考虑特殊情况，空树也是对称树

后续遍历，递归检查
```c++
// 如果两个子树都为空，说明是对称的

        if (!left && !right) return true;

        // 如果其中一个为空，另一个不为空，说明不对称

        if (!left || !right) return false;

        // 如果两个子树的根节点值不同，说明不对称

        if (left->val != right->val) return false;

        // 递归检查左子树的左节点和右子树的右节点，左子树的右节点和右子树的左节点
```