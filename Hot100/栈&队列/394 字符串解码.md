给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例 1：**
**输入：s = "3[a]2[bc]"
输出：**"aaabcbc"

**示例 2：**
**输入：s = "3[a2[c]]"
输出：**"accaccacc"

**示例 3：**
**输入：s = "2[abc]3[cd]ef"
输出：**"abcabccdcdcdef"

**示例 4：**
**输入：s = "abc3[cd]xyz"
输出：**"abccdcdcdxyz"

**提示：**
- `1 <= s.length <= 30`
- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
- `s` 保证是一个 **有效** 的输入。
- `s` 中所有整数的取值范围为 `[1, 300]`


## 思路

一共四种类型的字符
1. $[$，遇到开括号需要把之前的数字和字符串入栈
2. $]$，出栈，并循环
3. 数字，更新全局的数字
4. 字符，更新currents,在遇到$[$入栈
关键
==数字可能是多位数==




```c++
#include <string>
using namespace std;

class Solution {
public:
    int index = 0; // 全局索引，用于跟踪当前处理的位置

    string decodeString(string s) {
        string result = "";
        int k = 0;

        while (index < s.size()) {
            char currentChar = s[index];
            
            if (isdigit(currentChar)) {
                // 计算数字，处理多位数
                k = 0;
                while (index < s.size() && isdigit(s[index])) {
                    k = k * 10 + (s[index] - '0');
                    index++;
                }
            }
            else if (currentChar == '[') {
                // 进入递归处理括号内的字符串
                index++; // 跳过 '['
                string decodedString = decodeString(s);
                // 将解码后的字符串重复k次并添加到结果中
                while (k > 0) {
                    result += decodedString;
                    k--;
                }
            }
            else if (currentChar == ']') {
                // 结束当前递归层级
                index++; // 跳过 ']'
                return result;
            }
            else {
                // 处理字母，直接添加到结果中
                result += currentChar;
                index++;
            }
        }

        return result;
    }
};

```