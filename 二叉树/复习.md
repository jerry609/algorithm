## 104 二叉树的最大深度

后续遍历

## 中序遍历
递归
==栈==

## 反转二叉树

层序遍历

## ==对称二叉树==
考虑特殊情况，空树也是对称树

后续遍历，递归检查
```c++
// 如果两个子树都为空，说明是对称的

        if (!left && !right) return true;

        // 如果其中一个为空，另一个不为空，说明不对称

        if (!left || !right) return false;

        // 如果两个子树的根节点值不同，说明不对称

        if (left->val != right->val) return false;

        // 递归检查左子树的左节点和右子树的右节点，左子树的右节点和右子树的左节点
```


## ==二叉树的直径==
二叉树的深度上修改一部分代码
当前节点的路径长度 = 左子树高度 + 右子树高度

##   将有序数组转换为二叉搜索树
(https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
边界问题
```c++
class Solution {
public:
    TreeNode* helper(int left, int right, vector<int>& nums) {
        if(left > right) return nullptr;
        
        int mid = left + (right - left) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        
        // 错误：
        root->left = helper(0, mid-1, nums);         // left 应该保持为当前的 left
        root->right = helper(mid+1, nums.size()-1, nums);  // right 应该保持为当前的 right
        
        // 正确：
        root->left = helper(left, mid-1, nums);      // 使用当前范围的左边界
        root->right = helper(mid+1, right, nums);    // 使用当前范围的右边界
        
        return root;
    }
    
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(0, nums.size()-1, nums);
    }
};
```

 ==root->left = helper(left,mid-1,nums);==
 ==root->right = helper(mid+1,right,nums);==
## ==验证二叉搜索树==
不仅要和直接父节点比较，还要和所有祖先节点比较
所有左节点小于跟节点，所有右节点大于根节点

这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。


## 二叉搜索树中第k小的元素
中序遍历
遍历k次停止
```c++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode *> stack;
        while (root != nullptr || stack.size() > 0) {
            while (root != nullptr) {
                stack.push(root);
                root = root->left;
            }
            root = stack.top();
            stack.pop();
            --k;
            if (k == 0) {
                break;
            }
            root = root->right;
        }
        return root->val;
    }
};
```
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？
## 从前序与中序遍历序列构造二叉树


## 二叉树中和为某一值的路径
既然要找所有路径上节点和等于目标值的路径个数，那我们肯定先找这样的路径起点啊，但是我们不知道起点究竟在哪里，而且任意节点都有可能是起点，那我们就前序遍历二叉树的所有节点，每个节点都可以作为一次起点，即子树的根节点。

|   |   |
|---|---|
|1<br><br>2<br><br>3|`//以其子结点为新根`<br><br>`FindPath(root.left, sum);`<br><br>`FindPath(root.right, sum);`|

查找路径的时候呢，也需要往下遍历，因此还可以继续前序遍历该子树，在遍历的过程遇到一个节点，sum相应减少，若是到最后往下的一个节点值正好等于剩下的sum，则找到一种情况。

|   |   |
|---|---|
|1<br><br>2<br><br>3|`//符合目标值`<br><br>`if``(sum == root.val)`<br><br>    `res++;`|

因为前序递归的次序是根左右，因此一定是往下找的路径，不会往上回溯。

|   |   |
|---|---|
|1<br><br>2<br><br>3|`//进入子节点继续找`<br><br>`dfs(root.left, sum - root.val);`<br><br>`dfs(root.right, sum - root.val);`|

**具体做法：**

- step 1：每次将原树中遇到的节点作为子树的根节点送入dfs函数中查找有无路径，如果该节点为空则返回。
- step 2：然后递归遍历这棵树每个节点，每个节点都需要这样操作。
- step 3：在dfs函数中，也是往下递归，遇到一个节点就将sum减去节点值再往下。
- step 4：剩余的sum等于当前节点值则找到一种情况。

==前缀和==
```c++
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
  public:
    /**
     * 前缀和优化方法
     */
    int countPathSum(TreeNode* node, int sum, long currentSum,
                     unordered_map<long, int>& prefixSumCount) {
        if (node == nullptr) return 0;

        // 更新当前路径和
        currentSum += node->val;

        // 检查是否有前缀和等于 currentSum - sum
        int count = 0;
        if (prefixSumCount.find(currentSum - sum) != prefixSumCount.end()) {
            count += prefixSumCount[currentSum - sum];
        }

        // 更新前缀和的频率
        prefixSumCount[currentSum]++;

        // 递归左子树和右子树
        count += countPathSum(node->left, sum, currentSum, prefixSumCount);
        count += countPathSum(node->right, sum, currentSum, prefixSumCount);

        // 回溯，减少当前路径和的频率
        prefixSumCount[currentSum]--;

        return count;
    }

    int FindPath(TreeNode* root, int sum) {
        unordered_map<long, int> prefixSumCount;
        prefixSumCount[0] = 1; // 基础条件，空路径的前缀和为 0
        return countPathSum(root, sum, 0, prefixSumCount);
    }
};
```

```c++
/**

 * Definition for a binary tree node.

 * struct TreeNode {

 *     int val;

 *     TreeNode *left;

 *     TreeNode *right;

 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}

 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}

 * };

 */

class Solution {

public:

    int res = 0;

    void dfs(TreeNode* root, int targetSum) {

        if(root == nullptr) return;

        // 以当前节点为起点搜索路径

        findPath(root, 0, targetSum);

        // 递归搜索左右子树

        dfs(root->left, targetSum);

        dfs(root->right, targetSum);

    }

    void findPath(TreeNode* root, long long currSum, int targetSum) {

        if(root == nullptr) return;

        // 更新当前路径和

        currSum += root->val;

        // 检查是否找到一条满足条件的路径

        if(currSum == targetSum) res++;

        // 继续搜索左右子树

        findPath(root->left, currSum, targetSum);

        findPath(root->right, currSum, targetSum);

    }

    int pathSum(TreeNode* root, int targetSum) {

        dfs(root, targetSum);

        return res;

    }

};
```


## 展开成二叉树

```c++
        // Set all left pointers to null and connect right pointers
        for(int i = 0; i < p.size(); i++) {
            p[i]->left = nullptr;
            p[i]->right = (i + 1 < p.size()) ? p[i + 1] : nullptr;
        }
```

## ==二叉树的右视图==

怎么采用深度优先搜索
```c++
class Solution {

public:

    vector<int> rightSideView(TreeNode* root) {

        vector<int> res;

        dfs(root, 0, res);  // 深度优先搜索

        return res;

    }

private:

    void dfs(TreeNode* root, int depth, vector<int>& res) {

        if (!root) return;

        // 当前深度第一个访问的节点(因为是先右后左，所以是最右节点)

        if (depth == res.size()) {

            res.push_back(root->val);

        }

        // 先访问右子树，再访问左子树

        dfs(root->right, depth + 1, res);

        dfs(root->left, depth + 1, res);

    }

};
```

## 二叉树的最近公共祖先

