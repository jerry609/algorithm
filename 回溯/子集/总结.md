## 78 子集
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
`示例: 输入: nums = [1,2,3] 输出: [ [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]`

### 思路
回溯返回条件，`index==num,size()`

```c++
class Solution {

public:

    vector<vector<int>>res;
    void backtracing(vector<int>& nums,vector<int>& path,int startIndex){
        if(startIndex==nums.size()){
            return;
        }

        for(int i = startIndex;i<nums.size();i++){
            path.push_back(nums[i]);
            res.push_back(path);
            startIndex++;
            backtracing(nums,path,startIndex);
            path.pop_back();
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> path;
        int startIndex=0;
        res.push_back(path);
        backtracing(nums,path,startIndex);
        return res;
    }

};
```
## 90 子集
给定一个==可能包含重复元素==的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例:
- 输入: [1,2,2]
- 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]

### 思路
参考组合总和||，关键是去重
有了index就不需要used数组
```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(vector<int>& nums, int startIndex) {
        // 每个路径都是一个合法的子集，直接加入结果
        res.push_back(path);
        // 遍历当前可选的数字
        for(int i = startIndex; i < nums.size(); i++) {
            // 跳过重复元素（同一层）
            if(i > startIndex && nums[i] == nums[i-1]) {
                continue;
            }
            // 选择当前数字
            path.push_back(nums[i]);
            // 递归搜索
            dfs(nums, i + 1);
            // 回溯，撤销选择
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());  // 排序，便于去重
        dfs(nums, 0);
        return res;
    }
};
```
## 491 递增子序列

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
示例:
- 输入: [4, 6, 7, 7]
- `输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]`
说明:
- 给定数组的长度不会超过15。
- 数组中的整数范围是 [-100,100]。
- 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。
==题目要求递增子序列大小至少为2==
### 思路

1. 剪枝，选出所有组合，然后找到递增序列
**`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！**

注意：
 ==// 用于判断是否可以将当前元素添加到路径中==

    bool isValid(vector<int>& nums, int i, unordered_set<int>& used) {

        return (path.empty() || nums[i] >= path.back()) && !used.count(nums[i]);

    }

```c++
class Solution {

public:
    vector<vector<int>> res;
    vector<int> path;
    // 用于判断是否可以将当前元素添加到路径中
    bool isValid(vector<int>& nums, int i, unordered_set<int>& used) {
        return (path.empty() || nums[i] >= path.back()) && !used.count(nums[i]);
    }
    void backtracing(vector<int>& nums, int startIndex) {
        if (path.size() >= 2) { // 确保只存储有效长度的路径
            res.push_back(path);
        }

        if (startIndex == nums.size()) return;
        unordered_set<int> used; // 用于记录当前层级访问过的数字
        for (int i = startIndex; i < nums.size(); i++) {
            // 使用封装后的 isValid 函数来判断是否可以继续
            if (!isValid(nums, i, used)) {
                continue;
            }
            used.insert(nums[i]); // 记录当前数字
            path.push_back(nums[i]);
            backtracing(nums, i + 1);
            path.pop_back(); // 回溯
        }
    }

    vector<vector<int>> findSubsequences(vector<int>& nums) {
        res.clear();
        path.clear();
        backtracing(nums, 0);
        return res;
    }
};
```

