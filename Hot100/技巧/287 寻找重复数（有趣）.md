给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**
**输入：nums = [1,3,4,2,2]
输出：2

**示例 2：**
**输入：nums = [3,1,3,4,2]
输出：3

**示例 3 :**
**输入：nums = [3,3,3,3,3]
输出：3

**提示：**
- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

**进阶：**

- 如何证明 `nums` 中至少存在一个重复的数字?
    
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

## 思路

鸽巢原理
1. 二分法
这是一个很好的问题。这里的二分查找与常规二分查找有所不同，它二分的是**数值范围**而不是数组索引。让我来详细解释这种二分查找的有序性：

# 1. 常规二分查找 vs 这道题的二分查找

常规二分查找：
- 在已排序数组中查找目标值
- 二分的是数组的索引范围
- 通过比较中间元素的值来缩小查找范围

这道题的二分查找：
- 在1到n的数值范围内查找重复数
- 二分的是可能的数值范围
- 通过统计小于等于中间值的数字个数来缩小范围

# 2. 有序性的体现

这里的有序性体现在数字计数的性质上：

假设数组为 [1,3,4,2,2]，n=4：

1. 对于范围[1,4]中的每个数字k，定义count(k)为数组中小于等于k的数字个数
2. 这会形成一个具有单调性的序列：
   ```
   k = 1: count(1) = 1  // 只有一个1
   k = 2: count(2) = 3  // 有1和两个2
   k = 3: count(3) = 4  // 有1,两个2,和3
   k = 4: count(4) = 5  // 所有数字
   ```

这个count序列具有以下性质：
- 单调递增
- 在重复数字及其之后的位置，count(k) > k
- 在重复数字之前的位置，count(k) ≤ k

# 3. 举例说明

以 [1,3,4,2,2] 为例：

```plaintext
第一次二分：
- 范围[1,4], mid = 2
- count(2) = 3 > mid   
- 说明重复数字在[1,2]范围内

第二次二分：
- 范围[1,2], mid = 1
- count(1) = 1 = mid
- 说明重复数字在[2,2]范围内

结果：
- left = right = 2，找到重复数字2
```

# 4. 正确性证明

1. 如果k小于重复数字：
   - 数组中≤k的数字最多有k个
   - 因此count(k) ≤ k

2. 如果k大于或等于重复数字：
   - 由于重复数字出现至少两次
   - 数组中≤k的数字个数会大于k
   - 因此count(k) > k

这种单调性保证了二分查找能够正确工作：
- 当count(mid) > mid时，重复数字在左半部分
- 当count(mid) ≤ mid时，重复数字在右半部分

所以，虽然原数组并未排序，但通过count函数建立的这种映射关系具有单调性，这就是这个二分算法能够工作的关键。这是一个很巧妙的转化，将无序数组的查找转化为了有序范围上的二分查找。



让我详细解释 Floyd 判圈法（Floyd's Cycle-Finding Algorithm），也被称为"龟兔赛跑算法"。

让我们结合这道找重复数字的题目来分析：

# 1. 核心思想

Floyd判圈法用两个指针以不同速度遍历序列，最终会在环内相遇。
- 快指针（兔子）：每次移动两步
- 慢指针（乌龟）：每次移动一步

```python
def findDuplicate(nums):
    # 初始化快慢指针
    slow = nums[0]
    fast = nums[0]
    
    # 阶段1：找到相遇点
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    
    # 阶段2：找到环的入口
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    
    return slow
```

# 2. 算法步骤详解

## 阶段1：检测环的存在并找到相遇点
1. 两个指针从同一起点出发
2. 慢指针每次走一步：`slow = nums[slow]`
3. 快指针每次走两步：`fast = nums[nums[fast]]`
4. 如果存在环，两个指针必然相遇

## 阶段2：找到环的入口（重复数字）
1. 将慢指针重置到起点：`slow = nums[0]`
2. 保持快指针在相遇点
3. 两个指针现在都每次走一步
4. 再次相遇的点就是环的入口（即重复的数字）

# 3. 为什么这种方法可行？

以示例 `nums = [1,3,4,2,2]` 为例：

1. 将数组值看作指向下一个位置的指针：
```
索引：  0  1  2  3  4
数值：  1  3  4  2  2
指向：  1->3->2->4->2->4->2...
```

2. 这形成了一个带环的链表：
```
1 -> 3 -> 2 ⭕️-> 4 
         ⬆️    ⬇️
         └----┘
```

3. 环的入口就是重复的数字（在这个例子中是2）

# 4. 数学证明

假设：
- 起点到环入口距离为F
- 环入口到相遇点距离为a
- 环的长度为C

当两指针相遇时：
1. 慢指针走了：F + a
2. 快指针走了：F + nC + a（n为某个整数）
3. 由于快指针速度是慢指针的2倍：
   ```
   2(F + a) = F + nC + a
   F + a = nC
   F = nC - a
   ```
4. 这说明从起点到环入口的距离等于从相遇点到环入口的距离

# 5. 时空复杂度

- 时间复杂度：O(n)
  - 第一阶段：O(n)
  - 第二阶段：O(n)
- 空间复杂度：O(1)
  - 只使用了两个指针变量
