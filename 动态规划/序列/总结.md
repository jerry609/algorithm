## 1. 最长上升子序列（有判断条件）

==`dp[i]` 表示以第 `i` 个元素 `nums[i]` 结尾的最长上升子序列的长度。每一位数的最长作为序列的长度可能有多个值，但是只能选择最大的那个，比如[2,6,3,5,7]，7作为序列的最大长度有3和4选择4，后续如果7后面还有数字选择的也应该是4而不是2，然后递推，每一位都应该选择它的最大值。==
==如何确定7的最大值呢那就是不断和前面比较，如果大就+1==
==dp[i] = max(dp[i],dp[j]+1)==

最长上升子序列（Longest Increasing Subsequence, LIS）是一个经典的动态规划问题。给定一个由整数构成的序列，找到其中最长的严格递增的子序列。下面我们将详细介绍如何通过动态规划方法解决这一问题。

### 1.1 dp[i]定义

**动态规划数组 `dp` 的定义**：

- `dp[i]` 表示以第 `i` 个元素 `nums[i]` 结尾的最长上升子序列的长度。

**解释**：

- 通过定义 `dp[i]`，我们能够将问题分解为子问题：对于每个位置 `i`，找出以 `nums[i]` 结尾的最长上升子序列的长度。最终的答案是所有 `dp[i]` 中的最大值。

### 1.2 状态转移方程

**状态转移方程**：$dp[i] = \max_{0 \leq j < i \text{且} nums[j] < nums[i]} (dp[j] + 1)$
**解释**：

- 对于每个位置 `i`，我们需要遍历其之前的所有位置 `j`（`0 ≤ j < i`），如果 `nums[j] < nums[i]`，说明可以将 `nums[i]` 接在 `nums[j]` 所在的上升子序列之后，形成一个更长的上升子序列。
- 因此，`dp[i]` 就是所有满足条件的 `dp[j] + 1` 中的最大值。

**边界情况**：

- 如果没有任何 `j` 满足 `nums[j] < nums[i]`，则 `dp[i] = 1`，即 `nums[i]` 本身就是一个长度为 1 的上升子序列。

### 1.3 dp[i]初始化

**初始化**：

- 对于所有 `i`，初始化 `dp[i] = 1`。

**解释**：

- 每个单独的元素本身就是一个长度为 1 的上升子序列，因此初始时每个 `dp[i]` 至少为 1。

### 1.4 确定遍历顺序

**遍历顺序**：

- 外层循环从左到右遍历序列中的每个元素 `i`（从 `0` 到 `n-1`）。
- 内层循环对于每个 `i`，遍历其之前的所有元素 `j`（从 `0` 到 `i-1`）。

**解释**：

- 通过这种顺序，我们确保在计算 `dp[i]` 时，所有可能影响 `dp[i]` 的 `dp[j]` 都已经被计算出来。

### 1.5 举例推导dp数组

**示例**：

考虑序列 `nums = [10, 9, 2, 5, 3, 7, 101, 18]`。

**步骤**：

1. **初始化**：
   ```
   dp = [1, 1, 1, 1, 1, 1, 1, 1]
   ```

2. **计算 dp[1]** (`nums[1] = 9`)：
   - 比较 `nums[1]` 和 `nums[0]`：
     - `9 < 10` 不满足 `nums[j] < nums[i]`，因此 `dp[1]` 仍为 1。

3. **计算 dp[2]** (`nums[2] = 2`)：
   - 比较 `nums[2]` 和 `nums[0]`：
     - `2 < 10` 不满足。
   - 比较 `nums[2]` 和 `nums[1]`：
     - `2 < 9` 不满足。
   - `dp[2] = 1`

4. **计算 dp[3]** (`nums[3] = 5`)：
   - 比较 `nums[3]` 和 `nums[0]`：
     - `5 < 10` 不满足。
   - 比较 `nums[3]` 和 `nums[1]`：
     - `5 < 9` 不满足。
   - 比较 `nums[3]` 和 `nums[2]`：
     - `5 > 2` 满足，`dp[3] = max(1, dp[2] + 1) = 2`
   - 更新 `dp`：
     ```
     dp = [1, 1, 1, 2, 1, 1, 1, 1]
     ```

5. **计算 dp[4]** (`nums[4] = 3`)：
   - 比较 `nums[4]` 和 `nums[0]`：
     - `3 < 10` 不满足。
   - 比较 `nums[4]` 和 `nums[1]`：
     - `3 < 9` 不满足。
   - 比较 `nums[4]` 和 `nums[2]`：
     - `3 > 2` 满足，`dp[4] = max(1, dp[2] + 1) = 2`
   - 比较 `nums[4]` 和 `nums[3]`：
     - `3 < 5` 不满足。
   - 更新 `dp`：
     ```
     dp = [1, 1, 1, 2, 2, 1, 1, 1]
     ```

6. **计算 dp[5]** (`nums[5] = 7`)：
   - 比较 `nums[5]` 和 `nums[0]`：
     - `7 < 10` 不满足。
   - 比较 `nums[5]` 和 `nums[1]`：
     - `7 < 9` 不满足。
   - 比较 `nums[5]` 和 `nums[2]`：
     - `7 > 2` 满足，`dp[5] = max(1, dp[2] + 1) = 2`
   - 比较 `nums[5]` 和 `nums[3]`：
     - `7 > 5` 满足，`dp[5] = max(2, dp[3] + 1) = 3`
   - 比较 `nums[5]` 和 `nums[4]`：
     - `7 > 3` 满足，`dp[5] = max(3, dp[4] + 1) = 3`
   - 更新 `dp`：
     ```
     dp = [1, 1, 1, 2, 2, 3, 1, 1]
     ```

7. **计算 dp[6]** (`nums[6] = 101`)：
   - 比较 `nums[6]` 和 `nums[0]` 到 `nums[5]`：
     - `101 > 10`，`dp[6] = max(1, dp[0] + 1) = 2`
     - `101 > 9`，`dp[6] = max(2, dp[1] + 1) = 2`
     - `101 > 2`，`dp[6] = max(2, dp[2] + 1) = 2`
     - `101 > 5`，`dp[6] = max(2, dp[3] + 1) = 3`
     - `101 > 3`，`dp[6] = max(3, dp[4] + 1) = 3`
     - `101 > 7`，`dp[6] = max(3, dp[5] + 1) = 4`
   - 更新 `dp`：
     ```
     dp = [1, 1, 1, 2, 2, 3, 4, 1]
     ```

8. **计算 dp[7]** (`nums[7] = 18`)：
   - 比较 `nums[7]` 和 `nums[0]` 到 `nums[6]`：
     - `18 > 10`，`dp[7] = max(1, dp[0] + 1) = 2`
     - `18 > 9`，`dp[7] = max(2, dp[1] + 1) = 2`
     - `18 > 2`，`dp[7] = max(2, dp[2] + 1) = 2`
     - `18 > 5`，`dp[7] = max(2, dp[3] + 1) = 3`
     - `18 > 3`，`dp[7] = max(3, dp[4] + 1) = 3`
     - `18 > 7`，`dp[7] = max(3, dp[5] + 1) = 4`
     - `18 < 101`，不满足。
   - 更新 `dp`：
     ```
     dp = [1, 1, 1, 2, 2, 3, 4, 4]
     ```

**最终 `dp` 数组**：
```
dp = [1, 1, 1, 2, 2, 3, 4, 4]
```

**最长上升子序列的长度**：

- 最大值为 `4`，对应的子序列可能是 `[2, 3, 7, 101]` 或 `[2, 3, 7, 18]`。

这种方法的时间复杂度为 \(O(n^2)\)，对于较大的输入序列，可以通过优化如二分查找将时间复杂度降低到 \(O(n \log n)\)。


## 2. 最长连续递增序列

**dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。
注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。

和最长上升子序列不同的点是这个题目要求序列是连续的。
dp[i] = dp[i-1]+1

为什么初始为1，拿3举例子，后面比他大的4就是1+1为2
![[Pasted image 20241122213120.png]]

## 3. 最长重复子数组
```
dp[i][j]：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）
```
if i=j $dp[i][j]$ = $d[i-1][j-1] +1$

需要result数组进行保存最大值

## 4. 最长公共子序列
```
dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
```

![[Pasted image 20241122224147.png]]
![[Pasted image 20241122223250.png]]
## 5. 最大子序和
**dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**。
dp[i]只有两个方向可以推出来：

- dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
- nums[i]，即：从头开始计算当前连续子序列和

需要result数组进行保存最大值