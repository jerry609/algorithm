## 描述
给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。
1.返回第k小的节点值即可
2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1
3.保证n个节点的值不一样
  
数据范围： 0≤n≤10000≤n≤1000，0≤k≤10000≤k≤1000，树上每个结点的值满足0≤val≤10000≤val≤1000  
进阶：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)  

如输入{5,3,7,2,4,6,8},3时，二叉树{5,3,7,2,4,6,8}如下图所示：

![](https://uploadfiles.nowcoder.com/images/20211117/392807_1637120852509/F732B49BA33ECC72FF97FF7BDE2ACF69)  

该二叉树所有节点按结点值升序排列后可得[2,3,4,5,6,7,8]，所以第3个结点的结点值为4，故返回对应结点值为4的结点即可。
![image.png](https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/baguwen/20241201093906.png)


## 思路
##### 题目主要信息：

- 给定一棵节点数为n二叉搜索树，需要其中的第k小的节点值
- 返回第k小的节点值即可
- 不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1
- 保证n个节点的值不一样

##### 举一反三：

学习完本题的思路你可以解决如下题目：

[JZ68. 二叉搜索树的最近公共祖先](https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=13&tqId=2290592)

[JZ8. 二叉树的下一个节点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=23451)

##### 方法一：递归中序遍历（推荐使用）
中序遍历，因为右子树是流程中的最后一个语句，进入递归，所以在一开始进入递归的时候要进行条件判断，此时k已经增加过了，比进入左树的时候多了1；
```c++
 cnt++;
 //.....
 if (root == nullptr || cnt >= k) {
       return nullptr;
 }
```

**知识点：二叉树递归**

递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。因此递归过程，最重要的就是查看能不能讲原本的问题分解为更小的子问题，这是使用递归的关键。

而二叉树的递归，则是将某个节点的左子树、右子树看成一颗完整的树，那么对于子树的访问或者操作就是对于原树的访问或者操作的子问题，因此可以自我调用函数不断进入子树。

**思路：**

根据二叉搜索树的性质，左子树的元素都小于根节点，右子树的元素都大于根节点。因此它的中序遍历（左中右）序列正好是由小到大的次序，因此我们可以尝试递归中序遍历，也就是从最小的一个节点开始，找到k个就是我们要找的目标。

**具体做法：**

- step 1：设置全局变量count记录遍历了多少个节点，res记录第k个节点。
- step 2：另写一函数进行递归中序遍历，当节点为空或者超过k时，结束递归，返回。
- step 3：优先访问左子树，再访问根节点，访问时统计数字，等于k则找到。
- step 4：最后访问右子树。

**图示：**

![图片说明](https://uploadfiles.nowcoder.com/images/20210715/397721558_1626280110464/AD840828372A5B112A2F2C26B88D4243 "图片标题")
##### 方法二：非递归中序遍历

**知识点：栈**

栈是一种仅支持在表尾进行插入和删除操作的线性表，这一端被称为栈顶，另一端被称为栈底。元素入栈指的是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；元素出栈指的是从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

**思路：**

递归实际上就是一种先进后出的栈结构，因此能用递归进行的中序遍历，非递归（栈）也可以实现，还是需要记录遍历到第k位即截止。

**具体做法：**

- step 1：用栈记录当前节点，不断往左深入，直到左边子树为空。
- step 2：再弹出栈顶（即为当前子树的父节点），访问该节点，同时计数。
- step 3：然后再访问其右子树，其中每棵子树都遵循左中右的次序。
- step 4：直到第k个节点返回，如果遍历结束也没找到，则返回-1.


```c++
/**

 * struct TreeNode {

 *  int val;

 *  struct TreeNode *left;

 *  struct TreeNode *right;

 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

 * };

 */

class Solution {

public:

    /**

     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可

     *

     *

     * @param proot TreeNode类

     * @param k int整型

     * @return int整型

     */

    int KthNode(TreeNode* proot, int k) {

        // write code here

    }

};
```