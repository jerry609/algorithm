给你一个字符串 `s`，找到 `s` 中最长的 回文子串。

**示例 1：**
**输入：s = "babad"
输出：**"bab"
**解释：**"aba" 同样是符合题意的答案。

**示例 2：**
**输入：s = "cbbd"
输出：**"bb"

**提示：**
- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

## 思路

状态表示：
- `dp[i][j]`: 表示字符串s从下标i到j这段区间的最长回文子序列的长度
- i: 区间左端点
- j: 区间右端点

状态转移方程：
```
if (s[i] == s[j]) {
    dp[i][j] = dp[i+1][j-1] + 2;
} else {
    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
}
```

解释：
1. 当 $s[i] == s[j]$ 时：
   - 说明可以将这两个字符加入到回文子序列中
   - $dp[i+1][j-1]$ 是去掉两端后的子区间的最长回文子序列长度
   - +2 表示在原有长度基础上两端各增加一个字符

2. 当 $s[i] != s[j]$ 时：
   - 说明这两个字符不能同时作为回文子序列的两端
   - 需要考虑去掉左端点或右端点的情况，取较大值
   - $dp[i+1][j]$: 不包含左端点的子区间
   - $dp[i][j-1]$: 不包含右端点的子区间

边界条件：
- `dp[i][i] = 1`: 单个字符的回文子序列长度为1

计算顺序：
- i从大到小
- j从小到大
- 保证计算$dp[i][j]$时，$dp[i+1][j-1], dp[i+1][j]$, $dp[i][j-1]$都已经计算出来