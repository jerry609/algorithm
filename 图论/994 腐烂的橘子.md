给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

**示例 1：**
**输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

**示例 2：**
**输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3

**提示：**
- `m == grid.length
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`
### 思路
遍历一次就要给出是否还剩橘子不太现实，所以第一次先统计新鲜橘子和
很像二叉树的层序遍历
1. 因为是bfs,所以使用栈或者队列 
2. 两层while，que里面是每一层的烂橘子
3. 检查四个方向
4. 新的腐烂加入que

```c++
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        queue<pair<int, int>> q;  // 用于BFS的队列
        int fresh = 0, minutes = 0;  // 新鲜橘子计数和时间计数
        // 统计新鲜橘子数量并将腐烂橘子位置加入队列
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < cols; j++) {
                if(grid[i][j] == 1) fresh++;
                else if(grid[i][j] == 2) q.push({i, j});
            }
        }
        // 四个方向的位置偏移
        vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
        // 逐层处理腐烂过程
        while(!q.empty() && fresh > 0) {
            int size = q.size();
            while(size--) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                // 检查四个相邻位置
                for(auto dir : dirs) {
                    int nx = x + dir.first;
                    int ny = y + dir.second;
                    if(nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;  // 使橘子腐烂
                        fresh--;  // 更新新鲜橘子数量
                        q.push({nx, ny});  // 将新腐烂的橘子加入队列
                    }
                }
            }
            minutes++;  // 每处理完一层，时间加1
        }
        return fresh == 0 ? minutes : -1;  // 如果还有新鲜橘子，返回-1
    }
};
```

