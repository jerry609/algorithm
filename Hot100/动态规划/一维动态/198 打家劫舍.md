你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**
**输入：**[1,2,3,1]
**输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2：**
**输入：**[2,7,9,3,1]
**输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

**提示：**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`


## 思路
在“打家劫舍”问题中，状态转移方程是动态规划的核心部分。状态转移方程用于描述如何从前一个或前几个子问题的解推导出当前子问题的解。
### 状态定义
- `dp[i]` 表示从第一个房屋到第 `i` 个房屋能获得的最大金额。
### 状态转移方程
对于每个房屋 `i`，有两种选择：
1. **不抢劫第 `i` 个房屋**: 那么最大金额就是 `dp[i-1]`。
2. **抢劫第 `i` 个房屋**: 那么就不能抢劫第 `i-1` 个房屋，最大金额就是 `dp[i-2] + nums[i]`。
因此，状态转移方程为：$dp[i] = \max(dp[i-1], dp[i-2] + nums[i])$
### 初始条件
- `dp[0] = nums[0]`: 只有一个房屋时，最大金额就是该房屋的价值。
- `dp[1] = max(nums[0], nums[1])`: 有两个房屋时，最大金额是这两个房屋中的较大者。
### 注释解释：
1. **检查 `nums` 是否为空**: 如果 `nums` 为空，直接返回0。
2. **处理单个房屋的情况**: 如果 `nums` 只有一个元素，直接返回该元素的值。
3. **初始化 `dp` 数组**: 创建一个大小与 `nums` 相同的 `dp` 数组，并将其所有元素初始化为0。
4. **设置初始值**:
   - `dp[0] = nums[0]`: 第一个房屋的最大价值就是其自身价值。
   - `dp[1] = std::max(nums[0], nums[1])`: 第二个房屋的最大价值是前两个房屋中的较大者。
5. **动态规划计算**:
   - 从第三个房屋开始遍历 (`i = 2`)。
   - 对于每个房屋 `i`，计算其最大价值为 `std::max(dp[i - 2] + nums[i], dp[i - 1])`，即要么抢当前房屋和前两个房屋的最大价值之和，要么不抢当前房屋，取前一个房屋的最大价值。
6. **返回结果**: 返回 `dp` 数组的最后一个元素 `dp[nums.size() - 1]`，即为整个数组的最大抢劫价值。

通过这种方式，我们可以有效地解决“打家劫舍”问题，并且代码逻辑清晰、易于理解。
```c++
#include <vector>
#include <algorithm>

class Solution {
public:
    int rob(std::vector<int>& nums) {
        if (nums.size() == 0) return 0;
        // 如果只有一个房屋，直接返回该房屋的价值
        if (nums.size() == 1) return nums[0];
        // 初始化 dp 数组
        std::vector<int> dp(nums.size(), 0);
        // 第一个房屋的最大价值就是其自身价值
        dp[0] = nums[0];
        // 第二个房屋的最大价值是前两个房屋中的较大者
        dp[1] = std::max(nums[0], nums[1]);
        // 从第三个房屋开始计算
        for (int i = 2; i < nums.size(); ++i) {
            // 计算当前房屋的最大价值：要么抢当前房屋和前两个房屋的最大价值之和，要么不抢当前房屋，取前一个房屋的最大价值
            dp[i] = std::max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        // 返回最后一个房屋的最大价值，即为整个数组的最大抢劫价值
        return dp[nums.size() - 1];
    }
};




```