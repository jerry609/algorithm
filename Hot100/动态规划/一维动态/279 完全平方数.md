给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量。
**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**
**输入：n = `12`
输出：3 
解释：**`12 = 4 + 4 + 4`

**示例 2：**
**输入：n = `13`
输出：2
解释：**`13 = 4 + 9`

**提示：**
- `1 <= n <= 104`

## 思路
- **初始化**：
    - `dp` 是长度为 n+1n+1n+1 的数组，初始值为 `INT_MAX`，表示一个较大的数。
    - `dp[0] = 0`，因为和为 0 时，不需要任何完全平方数。
- **动态转移**：
    - 对于每个数字 `i`，遍历所有可能的完全平方数 `j * j`，并更新 `dp[i]` 的值。
    - 转移方程为： $dp[i]=min⁡(dp[i],dp[i−j2]+1)dp[i] = \min(dp[i], dp[i - j^2] + 1)dp[i]=min(dp[i],dp[i−j2]+1)$
- **返回结果**：
    - 最终返回 `dp[n]`，表示组成和为 nnn 的最少完全平方数数量。

```c++
int numSquares(int n) {
    // 创建一个 DP 数组并初始化
    vector<int> dp(n + 1, INT_MAX);
    dp[0] = 0; // 和为 0 时需要 0 个完全平方数

    // 遍历从 1 到 n 的所有数字
    for (int i = 1; i <= n; ++i) {
        // 遍历所有可能的完全平方数
        for (int j = 1; j * j <= i; ++j) {
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }

    return dp[n];
}
```