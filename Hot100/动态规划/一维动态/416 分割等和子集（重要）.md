![image.png](https://obsidian-1311563466.cos.ap-guangzhou.myqcloud.com/baguwen/20241214134344.png)


给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**
**输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

**示例 2：**
**输入：*nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。

**提示：**
- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## 思路

1. 是否属于排列或者组合
2. 一种就是求出所有包含了两个子集的集合
3. 两层循环怎么扫完所有集合

忽略了特性就是两个等和子集，就说明target=sum/2
如果这个数组可以分成两半，那么只要实现当前数组满足了一半另一半就不用管了

最终如果能满足那么dp[j-num]中的j-num一定等于0，所以设置dp[0] = true

dp[i]表示满足和为i的子集为真或假

```c++
#include <vector>
#include <numeric>

class Solution {
public:
    bool canPartition(std::vector<int>& nums) {
        if (nums.size() == 0) return false;
        
        // 计算数组的总和
        int totalSum = std::accumulate(nums.begin(), nums.end(), 0);
        
        // 如果总和是奇数，无法分割成两个和相等的子集
        if (totalSum % 2 != 0) return false;
        
        // 目标和为总和的一半
        int target = totalSum / 2;
        
        // 创建一个大小为 target+1 的 dp 数组，初始化为 false
        std::vector<bool> dp(target + 1, false);
        
        // 基本情况：和为0的情况是可以实现的
        dp[0] = true;
        
        // 遍历每一个数字
        for (int num : nums) {
            // 从后向前遍历 dp 数组
            for (int j = target; j >= num; --j) {
                // 更新 dp[j] 为 dp[j] 或 dp[j - num]
                dp[j] = dp[j] || dp[j - num];
            }
        }
        
        // 返回 dp[target]，即是否可以组成目标和 target
        return dp[target];
    }
};
```